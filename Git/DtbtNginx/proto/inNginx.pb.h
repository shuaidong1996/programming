// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: inNginx.proto

#ifndef PROTOBUF_inNginx_2eproto__INCLUDED
#define PROTOBUF_inNginx_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
class AckData2Follower;
class AckData2FollowerDefaultTypeInternal;
extern AckData2FollowerDefaultTypeInternal _AckData2Follower_default_instance_;
class AckData2Leader;
class AckData2LeaderDefaultTypeInternal;
extern AckData2LeaderDefaultTypeInternal _AckData2Leader_default_instance_;
class AckVote2Follower;
class AckVote2FollowerDefaultTypeInternal;
extern AckVote2FollowerDefaultTypeInternal _AckVote2Follower_default_instance_;
class AckVote2Leader;
class AckVote2LeaderDefaultTypeInternal;
extern AckVote2LeaderDefaultTypeInternal _AckVote2Leader_default_instance_;
class HostName;
class HostNameDefaultTypeInternal;
extern HostNameDefaultTypeInternal _HostName_default_instance_;
class KeepAlive;
class KeepAliveDefaultTypeInternal;
extern KeepAliveDefaultTypeInternal _KeepAlive_default_instance_;
class Server2Nginx;
class Server2NginxDefaultTypeInternal;
extern Server2NginxDefaultTypeInternal _Server2Nginx_default_instance_;
class SynchData;
class SynchDataDefaultTypeInternal;
extern SynchDataDefaultTypeInternal _SynchData_default_instance_;
class Vote;
class VoteDefaultTypeInternal;
extern VoteDefaultTypeInternal _Vote_default_instance_;

namespace protobuf_inNginx_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_inNginx_2eproto

// ===================================================================

class HostName : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HostName) */ {
 public:
  HostName();
  virtual ~HostName();

  HostName(const HostName& from);

  inline HostName& operator=(const HostName& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HostName(HostName&& from) noexcept
    : HostName() {
    *this = ::std::move(from);
  }

  inline HostName& operator=(HostName&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HostName& default_instance();

  static inline const HostName* internal_default_instance() {
    return reinterpret_cast<const HostName*>(
               &_HostName_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(HostName* other);
  friend void swap(HostName& a, HostName& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HostName* New() const PROTOBUF_FINAL { return New(NULL); }

  HostName* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HostName& from);
  void MergeFrom(const HostName& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HostName* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string ip = 1;
  bool has_ip() const;
  void clear_ip();
  static const int kIpFieldNumber = 1;
  const ::std::string& ip() const;
  void set_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_ip(::std::string&& value);
  #endif
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  ::std::string* mutable_ip();
  ::std::string* release_ip();
  void set_allocated_ip(::std::string* ip);

  // required uint32 port = 2;
  bool has_port() const;
  void clear_port();
  static const int kPortFieldNumber = 2;
  ::google::protobuf::uint32 port() const;
  void set_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:HostName)
 private:
  void set_has_ip();
  void clear_has_ip();
  void set_has_port();
  void clear_has_port();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr ip_;
  ::google::protobuf::uint32 port_;
  friend struct protobuf_inNginx_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Vote : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Vote) */ {
 public:
  Vote();
  virtual ~Vote();

  Vote(const Vote& from);

  inline Vote& operator=(const Vote& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Vote(Vote&& from) noexcept
    : Vote() {
    *this = ::std::move(from);
  }

  inline Vote& operator=(Vote&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vote& default_instance();

  static inline const Vote* internal_default_instance() {
    return reinterpret_cast<const Vote*>(
               &_Vote_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Vote* other);
  friend void swap(Vote& a, Vote& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Vote* New() const PROTOBUF_FINAL { return New(NULL); }

  Vote* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Vote& from);
  void MergeFrom(const Vote& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Vote* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string nginxName = 2;
  bool has_nginxname() const;
  void clear_nginxname();
  static const int kNginxNameFieldNumber = 2;
  const ::std::string& nginxname() const;
  void set_nginxname(const ::std::string& value);
  #if LANG_CXX11
  void set_nginxname(::std::string&& value);
  #endif
  void set_nginxname(const char* value);
  void set_nginxname(const char* value, size_t size);
  ::std::string* mutable_nginxname();
  ::std::string* release_nginxname();
  void set_allocated_nginxname(::std::string* nginxname);

  // required uint32 version = 1;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  ::google::protobuf::uint32 version() const;
  void set_version(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Vote)
 private:
  void set_has_version();
  void clear_has_version();
  void set_has_nginxname();
  void clear_has_nginxname();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr nginxname_;
  ::google::protobuf::uint32 version_;
  friend struct protobuf_inNginx_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AckVote2Leader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:AckVote2Leader) */ {
 public:
  AckVote2Leader();
  virtual ~AckVote2Leader();

  AckVote2Leader(const AckVote2Leader& from);

  inline AckVote2Leader& operator=(const AckVote2Leader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AckVote2Leader(AckVote2Leader&& from) noexcept
    : AckVote2Leader() {
    *this = ::std::move(from);
  }

  inline AckVote2Leader& operator=(AckVote2Leader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckVote2Leader& default_instance();

  static inline const AckVote2Leader* internal_default_instance() {
    return reinterpret_cast<const AckVote2Leader*>(
               &_AckVote2Leader_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(AckVote2Leader* other);
  friend void swap(AckVote2Leader& a, AckVote2Leader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AckVote2Leader* New() const PROTOBUF_FINAL { return New(NULL); }

  AckVote2Leader* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AckVote2Leader& from);
  void MergeFrom(const AckVote2Leader& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AckVote2Leader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string nginxName = 2;
  bool has_nginxname() const;
  void clear_nginxname();
  static const int kNginxNameFieldNumber = 2;
  const ::std::string& nginxname() const;
  void set_nginxname(const ::std::string& value);
  #if LANG_CXX11
  void set_nginxname(::std::string&& value);
  #endif
  void set_nginxname(const char* value);
  void set_nginxname(const char* value, size_t size);
  ::std::string* mutable_nginxname();
  ::std::string* release_nginxname();
  void set_allocated_nginxname(::std::string* nginxname);

  // required uint32 version = 1;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  ::google::protobuf::uint32 version() const;
  void set_version(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:AckVote2Leader)
 private:
  void set_has_version();
  void clear_has_version();
  void set_has_nginxname();
  void clear_has_nginxname();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr nginxname_;
  ::google::protobuf::uint32 version_;
  friend struct protobuf_inNginx_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AckVote2Follower : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:AckVote2Follower) */ {
 public:
  AckVote2Follower();
  virtual ~AckVote2Follower();

  AckVote2Follower(const AckVote2Follower& from);

  inline AckVote2Follower& operator=(const AckVote2Follower& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AckVote2Follower(AckVote2Follower&& from) noexcept
    : AckVote2Follower() {
    *this = ::std::move(from);
  }

  inline AckVote2Follower& operator=(AckVote2Follower&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckVote2Follower& default_instance();

  static inline const AckVote2Follower* internal_default_instance() {
    return reinterpret_cast<const AckVote2Follower*>(
               &_AckVote2Follower_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(AckVote2Follower* other);
  friend void swap(AckVote2Follower& a, AckVote2Follower& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AckVote2Follower* New() const PROTOBUF_FINAL { return New(NULL); }

  AckVote2Follower* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AckVote2Follower& from);
  void MergeFrom(const AckVote2Follower& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AckVote2Follower* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string nginxName = 2;
  bool has_nginxname() const;
  void clear_nginxname();
  static const int kNginxNameFieldNumber = 2;
  const ::std::string& nginxname() const;
  void set_nginxname(const ::std::string& value);
  #if LANG_CXX11
  void set_nginxname(::std::string&& value);
  #endif
  void set_nginxname(const char* value);
  void set_nginxname(const char* value, size_t size);
  ::std::string* mutable_nginxname();
  ::std::string* release_nginxname();
  void set_allocated_nginxname(::std::string* nginxname);

  // required uint32 version = 1;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  ::google::protobuf::uint32 version() const;
  void set_version(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:AckVote2Follower)
 private:
  void set_has_version();
  void clear_has_version();
  void set_has_nginxname();
  void clear_has_nginxname();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr nginxname_;
  ::google::protobuf::uint32 version_;
  friend struct protobuf_inNginx_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SynchData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SynchData) */ {
 public:
  SynchData();
  virtual ~SynchData();

  SynchData(const SynchData& from);

  inline SynchData& operator=(const SynchData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SynchData(SynchData&& from) noexcept
    : SynchData() {
    *this = ::std::move(from);
  }

  inline SynchData& operator=(SynchData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SynchData& default_instance();

  static inline const SynchData* internal_default_instance() {
    return reinterpret_cast<const SynchData*>(
               &_SynchData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(SynchData* other);
  friend void swap(SynchData& a, SynchData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SynchData* New() const PROTOBUF_FINAL { return New(NULL); }

  SynchData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SynchData& from);
  void MergeFrom(const SynchData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SynchData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string sernames = 2;
  int sernames_size() const;
  void clear_sernames();
  static const int kSernamesFieldNumber = 2;
  const ::std::string& sernames(int index) const;
  ::std::string* mutable_sernames(int index);
  void set_sernames(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_sernames(int index, ::std::string&& value);
  #endif
  void set_sernames(int index, const char* value);
  void set_sernames(int index, const char* value, size_t size);
  ::std::string* add_sernames();
  void add_sernames(const ::std::string& value);
  #if LANG_CXX11
  void add_sernames(::std::string&& value);
  #endif
  void add_sernames(const char* value);
  void add_sernames(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& sernames() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_sernames();

  // required uint32 version = 1;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  ::google::protobuf::uint32 version() const;
  void set_version(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:SynchData)
 private:
  void set_has_version();
  void clear_has_version();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> sernames_;
  ::google::protobuf::uint32 version_;
  friend struct protobuf_inNginx_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AckData2Leader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:AckData2Leader) */ {
 public:
  AckData2Leader();
  virtual ~AckData2Leader();

  AckData2Leader(const AckData2Leader& from);

  inline AckData2Leader& operator=(const AckData2Leader& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AckData2Leader(AckData2Leader&& from) noexcept
    : AckData2Leader() {
    *this = ::std::move(from);
  }

  inline AckData2Leader& operator=(AckData2Leader&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckData2Leader& default_instance();

  static inline const AckData2Leader* internal_default_instance() {
    return reinterpret_cast<const AckData2Leader*>(
               &_AckData2Leader_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(AckData2Leader* other);
  friend void swap(AckData2Leader& a, AckData2Leader& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AckData2Leader* New() const PROTOBUF_FINAL { return New(NULL); }

  AckData2Leader* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AckData2Leader& from);
  void MergeFrom(const AckData2Leader& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AckData2Leader* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:AckData2Leader)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct protobuf_inNginx_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AckData2Follower : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:AckData2Follower) */ {
 public:
  AckData2Follower();
  virtual ~AckData2Follower();

  AckData2Follower(const AckData2Follower& from);

  inline AckData2Follower& operator=(const AckData2Follower& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AckData2Follower(AckData2Follower&& from) noexcept
    : AckData2Follower() {
    *this = ::std::move(from);
  }

  inline AckData2Follower& operator=(AckData2Follower&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckData2Follower& default_instance();

  static inline const AckData2Follower* internal_default_instance() {
    return reinterpret_cast<const AckData2Follower*>(
               &_AckData2Follower_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(AckData2Follower* other);
  friend void swap(AckData2Follower& a, AckData2Follower& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AckData2Follower* New() const PROTOBUF_FINAL { return New(NULL); }

  AckData2Follower* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AckData2Follower& from);
  void MergeFrom(const AckData2Follower& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AckData2Follower* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:AckData2Follower)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct protobuf_inNginx_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KeepAlive : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:KeepAlive) */ {
 public:
  KeepAlive();
  virtual ~KeepAlive();

  KeepAlive(const KeepAlive& from);

  inline KeepAlive& operator=(const KeepAlive& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KeepAlive(KeepAlive&& from) noexcept
    : KeepAlive() {
    *this = ::std::move(from);
  }

  inline KeepAlive& operator=(KeepAlive&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KeepAlive& default_instance();

  static inline const KeepAlive* internal_default_instance() {
    return reinterpret_cast<const KeepAlive*>(
               &_KeepAlive_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(KeepAlive* other);
  friend void swap(KeepAlive& a, KeepAlive& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KeepAlive* New() const PROTOBUF_FINAL { return New(NULL); }

  KeepAlive* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KeepAlive& from);
  void MergeFrom(const KeepAlive& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KeepAlive* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:KeepAlive)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  friend struct protobuf_inNginx_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Server2Nginx : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Server2Nginx) */ {
 public:
  Server2Nginx();
  virtual ~Server2Nginx();

  Server2Nginx(const Server2Nginx& from);

  inline Server2Nginx& operator=(const Server2Nginx& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Server2Nginx(Server2Nginx&& from) noexcept
    : Server2Nginx() {
    *this = ::std::move(from);
  }

  inline Server2Nginx& operator=(Server2Nginx&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Server2Nginx& default_instance();

  static inline const Server2Nginx* internal_default_instance() {
    return reinterpret_cast<const Server2Nginx*>(
               &_Server2Nginx_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(Server2Nginx* other);
  friend void swap(Server2Nginx& a, Server2Nginx& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Server2Nginx* New() const PROTOBUF_FINAL { return New(NULL); }

  Server2Nginx* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Server2Nginx& from);
  void MergeFrom(const Server2Nginx& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Server2Nginx* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string text = 2;
  bool has_text() const;
  void clear_text();
  static const int kTextFieldNumber = 2;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  #if LANG_CXX11
  void set_text(::std::string&& value);
  #endif
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // required uint32 port = 1;
  bool has_port() const;
  void clear_port();
  static const int kPortFieldNumber = 1;
  ::google::protobuf::uint32 port() const;
  void set_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Server2Nginx)
 private:
  void set_has_port();
  void clear_has_port();
  void set_has_text();
  void clear_has_text();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::google::protobuf::uint32 port_;
  friend struct protobuf_inNginx_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// HostName

// required string ip = 1;
inline bool HostName::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HostName::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HostName::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HostName::clear_ip() {
  ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ip();
}
inline const ::std::string& HostName::ip() const {
  // @@protoc_insertion_point(field_get:HostName.ip)
  return ip_.GetNoArena();
}
inline void HostName::set_ip(const ::std::string& value) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:HostName.ip)
}
#if LANG_CXX11
inline void HostName::set_ip(::std::string&& value) {
  set_has_ip();
  ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:HostName.ip)
}
#endif
inline void HostName::set_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:HostName.ip)
}
inline void HostName::set_ip(const char* value, size_t size) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:HostName.ip)
}
inline ::std::string* HostName::mutable_ip() {
  set_has_ip();
  // @@protoc_insertion_point(field_mutable:HostName.ip)
  return ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HostName::release_ip() {
  // @@protoc_insertion_point(field_release:HostName.ip)
  clear_has_ip();
  return ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HostName::set_allocated_ip(::std::string* ip) {
  if (ip != NULL) {
    set_has_ip();
  } else {
    clear_has_ip();
  }
  ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:HostName.ip)
}

// required uint32 port = 2;
inline bool HostName::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HostName::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HostName::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HostName::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 HostName::port() const {
  // @@protoc_insertion_point(field_get:HostName.port)
  return port_;
}
inline void HostName::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:HostName.port)
}

// -------------------------------------------------------------------

// Vote

// required uint32 version = 1;
inline bool Vote::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vote::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vote::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vote::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 Vote::version() const {
  // @@protoc_insertion_point(field_get:Vote.version)
  return version_;
}
inline void Vote::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:Vote.version)
}

// required string nginxName = 2;
inline bool Vote::has_nginxname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vote::set_has_nginxname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vote::clear_has_nginxname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vote::clear_nginxname() {
  nginxname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_nginxname();
}
inline const ::std::string& Vote::nginxname() const {
  // @@protoc_insertion_point(field_get:Vote.nginxName)
  return nginxname_.GetNoArena();
}
inline void Vote::set_nginxname(const ::std::string& value) {
  set_has_nginxname();
  nginxname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Vote.nginxName)
}
#if LANG_CXX11
inline void Vote::set_nginxname(::std::string&& value) {
  set_has_nginxname();
  nginxname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Vote.nginxName)
}
#endif
inline void Vote::set_nginxname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_nginxname();
  nginxname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Vote.nginxName)
}
inline void Vote::set_nginxname(const char* value, size_t size) {
  set_has_nginxname();
  nginxname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Vote.nginxName)
}
inline ::std::string* Vote::mutable_nginxname() {
  set_has_nginxname();
  // @@protoc_insertion_point(field_mutable:Vote.nginxName)
  return nginxname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Vote::release_nginxname() {
  // @@protoc_insertion_point(field_release:Vote.nginxName)
  clear_has_nginxname();
  return nginxname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Vote::set_allocated_nginxname(::std::string* nginxname) {
  if (nginxname != NULL) {
    set_has_nginxname();
  } else {
    clear_has_nginxname();
  }
  nginxname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nginxname);
  // @@protoc_insertion_point(field_set_allocated:Vote.nginxName)
}

// -------------------------------------------------------------------

// AckVote2Leader

// required uint32 version = 1;
inline bool AckVote2Leader::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckVote2Leader::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckVote2Leader::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckVote2Leader::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 AckVote2Leader::version() const {
  // @@protoc_insertion_point(field_get:AckVote2Leader.version)
  return version_;
}
inline void AckVote2Leader::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:AckVote2Leader.version)
}

// required string nginxName = 2;
inline bool AckVote2Leader::has_nginxname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckVote2Leader::set_has_nginxname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckVote2Leader::clear_has_nginxname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckVote2Leader::clear_nginxname() {
  nginxname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_nginxname();
}
inline const ::std::string& AckVote2Leader::nginxname() const {
  // @@protoc_insertion_point(field_get:AckVote2Leader.nginxName)
  return nginxname_.GetNoArena();
}
inline void AckVote2Leader::set_nginxname(const ::std::string& value) {
  set_has_nginxname();
  nginxname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AckVote2Leader.nginxName)
}
#if LANG_CXX11
inline void AckVote2Leader::set_nginxname(::std::string&& value) {
  set_has_nginxname();
  nginxname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AckVote2Leader.nginxName)
}
#endif
inline void AckVote2Leader::set_nginxname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_nginxname();
  nginxname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AckVote2Leader.nginxName)
}
inline void AckVote2Leader::set_nginxname(const char* value, size_t size) {
  set_has_nginxname();
  nginxname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AckVote2Leader.nginxName)
}
inline ::std::string* AckVote2Leader::mutable_nginxname() {
  set_has_nginxname();
  // @@protoc_insertion_point(field_mutable:AckVote2Leader.nginxName)
  return nginxname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AckVote2Leader::release_nginxname() {
  // @@protoc_insertion_point(field_release:AckVote2Leader.nginxName)
  clear_has_nginxname();
  return nginxname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AckVote2Leader::set_allocated_nginxname(::std::string* nginxname) {
  if (nginxname != NULL) {
    set_has_nginxname();
  } else {
    clear_has_nginxname();
  }
  nginxname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nginxname);
  // @@protoc_insertion_point(field_set_allocated:AckVote2Leader.nginxName)
}

// -------------------------------------------------------------------

// AckVote2Follower

// required uint32 version = 1;
inline bool AckVote2Follower::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckVote2Follower::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckVote2Follower::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckVote2Follower::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 AckVote2Follower::version() const {
  // @@protoc_insertion_point(field_get:AckVote2Follower.version)
  return version_;
}
inline void AckVote2Follower::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:AckVote2Follower.version)
}

// required string nginxName = 2;
inline bool AckVote2Follower::has_nginxname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckVote2Follower::set_has_nginxname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckVote2Follower::clear_has_nginxname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckVote2Follower::clear_nginxname() {
  nginxname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_nginxname();
}
inline const ::std::string& AckVote2Follower::nginxname() const {
  // @@protoc_insertion_point(field_get:AckVote2Follower.nginxName)
  return nginxname_.GetNoArena();
}
inline void AckVote2Follower::set_nginxname(const ::std::string& value) {
  set_has_nginxname();
  nginxname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AckVote2Follower.nginxName)
}
#if LANG_CXX11
inline void AckVote2Follower::set_nginxname(::std::string&& value) {
  set_has_nginxname();
  nginxname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AckVote2Follower.nginxName)
}
#endif
inline void AckVote2Follower::set_nginxname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_nginxname();
  nginxname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AckVote2Follower.nginxName)
}
inline void AckVote2Follower::set_nginxname(const char* value, size_t size) {
  set_has_nginxname();
  nginxname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AckVote2Follower.nginxName)
}
inline ::std::string* AckVote2Follower::mutable_nginxname() {
  set_has_nginxname();
  // @@protoc_insertion_point(field_mutable:AckVote2Follower.nginxName)
  return nginxname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AckVote2Follower::release_nginxname() {
  // @@protoc_insertion_point(field_release:AckVote2Follower.nginxName)
  clear_has_nginxname();
  return nginxname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AckVote2Follower::set_allocated_nginxname(::std::string* nginxname) {
  if (nginxname != NULL) {
    set_has_nginxname();
  } else {
    clear_has_nginxname();
  }
  nginxname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nginxname);
  // @@protoc_insertion_point(field_set_allocated:AckVote2Follower.nginxName)
}

// -------------------------------------------------------------------

// SynchData

// required uint32 version = 1;
inline bool SynchData::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SynchData::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SynchData::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SynchData::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 SynchData::version() const {
  // @@protoc_insertion_point(field_get:SynchData.version)
  return version_;
}
inline void SynchData::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:SynchData.version)
}

// repeated string sernames = 2;
inline int SynchData::sernames_size() const {
  return sernames_.size();
}
inline void SynchData::clear_sernames() {
  sernames_.Clear();
}
inline const ::std::string& SynchData::sernames(int index) const {
  // @@protoc_insertion_point(field_get:SynchData.sernames)
  return sernames_.Get(index);
}
inline ::std::string* SynchData::mutable_sernames(int index) {
  // @@protoc_insertion_point(field_mutable:SynchData.sernames)
  return sernames_.Mutable(index);
}
inline void SynchData::set_sernames(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:SynchData.sernames)
  sernames_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void SynchData::set_sernames(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:SynchData.sernames)
  sernames_.Mutable(index)->assign(std::move(value));
}
#endif
inline void SynchData::set_sernames(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  sernames_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SynchData.sernames)
}
inline void SynchData::set_sernames(int index, const char* value, size_t size) {
  sernames_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SynchData.sernames)
}
inline ::std::string* SynchData::add_sernames() {
  // @@protoc_insertion_point(field_add_mutable:SynchData.sernames)
  return sernames_.Add();
}
inline void SynchData::add_sernames(const ::std::string& value) {
  sernames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:SynchData.sernames)
}
#if LANG_CXX11
inline void SynchData::add_sernames(::std::string&& value) {
  sernames_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:SynchData.sernames)
}
#endif
inline void SynchData::add_sernames(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  sernames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SynchData.sernames)
}
inline void SynchData::add_sernames(const char* value, size_t size) {
  sernames_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SynchData.sernames)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SynchData::sernames() const {
  // @@protoc_insertion_point(field_list:SynchData.sernames)
  return sernames_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SynchData::mutable_sernames() {
  // @@protoc_insertion_point(field_mutable_list:SynchData.sernames)
  return &sernames_;
}

// -------------------------------------------------------------------

// AckData2Leader

// -------------------------------------------------------------------

// AckData2Follower

// -------------------------------------------------------------------

// KeepAlive

// -------------------------------------------------------------------

// Server2Nginx

// required uint32 port = 1;
inline bool Server2Nginx::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Server2Nginx::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Server2Nginx::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Server2Nginx::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 Server2Nginx::port() const {
  // @@protoc_insertion_point(field_get:Server2Nginx.port)
  return port_;
}
inline void Server2Nginx::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:Server2Nginx.port)
}

// required string text = 2;
inline bool Server2Nginx::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Server2Nginx::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Server2Nginx::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Server2Nginx::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_text();
}
inline const ::std::string& Server2Nginx::text() const {
  // @@protoc_insertion_point(field_get:Server2Nginx.text)
  return text_.GetNoArena();
}
inline void Server2Nginx::set_text(const ::std::string& value) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Server2Nginx.text)
}
#if LANG_CXX11
inline void Server2Nginx::set_text(::std::string&& value) {
  set_has_text();
  text_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Server2Nginx.text)
}
#endif
inline void Server2Nginx::set_text(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Server2Nginx.text)
}
inline void Server2Nginx::set_text(const char* value, size_t size) {
  set_has_text();
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Server2Nginx.text)
}
inline ::std::string* Server2Nginx::mutable_text() {
  set_has_text();
  // @@protoc_insertion_point(field_mutable:Server2Nginx.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Server2Nginx::release_text() {
  // @@protoc_insertion_point(field_release:Server2Nginx.text)
  clear_has_text();
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Server2Nginx::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    set_has_text();
  } else {
    clear_has_text();
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:Server2Nginx.text)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_inNginx_2eproto__INCLUDED
